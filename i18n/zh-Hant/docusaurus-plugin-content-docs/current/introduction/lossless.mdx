---
title: 無損壓縮
sidebar_position: 3
---

# Lossless Compression

:::info Under Maintenance
The content in this entry is incomplete & is in the process of being completed.
:::

無損壓縮是一種資料壓縮技術，能夠在壓縮後完全恢復原始資料。在需要完全保留原始內容完整性的應用場景中，這種技術尤為重要，例如在資料存檔、通用資料壓縮和專業媒體編輯中。為了理解無損壓縮的運作原理，我們首先需要了解冗餘、熵的概念，以及無損壓縮中常用的幾種壓縮技術。

### 冗餘與熵

了解冗餘與熵的概念對於深入理解無損壓縮至關重要。

**冗餘** 指的是資料中重複或可預測的部分。這些部分並不提供新信息，通過高效編碼可以減少資料大小，而不會損失任何信息。

**熵** 在信息理論中是用來衡量資料的隨機性或不可預測性。熵越低，冗餘度越高，意味著資料在理論上越容易壓縮。

在無損壓縮中，我們的目標是減少冗餘，並根據資料的熵進行最有效的編碼。


### 無損壓縮中的技術

1. **游程編碼 (run-length encoding,RLE)**：
   游程編碼是一種簡單的無損壓縮方法，將連續相同的資料值（即“游程”）儲存為單一資料值和計數。這種技術非常適合壓縮長時間重複的資料，例如靜音或恆定音調。例如，序列 `AAAAABBBCC` 可以被編碼為 `5A3B2C`。

2. **run-length encoding (Huffman Coding)**：
   霍夫曼編碼是一種熵編碼算法，用於無損資料壓縮。它通過將資料拆分為組成符號，並為每個符號分配編碼來工作。這個過程涉及構建一棵二叉樹，每個葉節點代表一個符號，從根到葉的路徑對應於該符號的二進制編碼。

   霍夫曼編碼在知道字符概率分佈的情況下效果最佳。假設你在記錄紅綠燈的狀態，它可能是綠色、黃色、紅色或因維修而關閉。根據統計，綠色出現的機率為 50%、紅色 40%、黃色 9%、關閉 1%。由於這裡有四種狀態，我們可以用兩位二進制數來表示。綠色可以用 `00`、紅色 `01`、黃色 `10`，關閉則為 `11`。然而，為了更有效地壓縮資料，我們可以根據各狀態的出現頻率分配編碼。例如，綠色頻率最高，所以分配 `0`，紅色 `11`，黃色 `100`，關閉 `101`。這樣，我們得到的霍夫曼編碼如下：
       - 綠色     (50%): `0`
       - 紅色     (40%): `11`
       - 黃色     ( 9%): `100`
       - 關閉     ( 1%): `101`

   樹狀結構如下所示：

   ![紅綠燈霍夫曼樹](https://raw.githubusercontent.com/av1-community-contributors/images/main/color-huffman-tree-svg.svg)

   通過計算概率與編碼長度的加權總和：
       (50% • 1) + (40% • 2) + (9% • 3) + (1% • 3) = **1.6**

   我們得到每個符號的平均 **1.6 位**。這顯示了霍夫曼編碼在節省空間方面的高效性，同時能夠無損地保留信息。
3. **算術編碼**
   算術編碼是一種熵編碼技術，它將整個訊息表示為 `[0, 1)` 區間中的一個單一數字。與霍夫曼編碼不同的是，霍夫曼編碼為輸入中的每個符號分配固定的二進制碼，而算術編碼則使用一個範圍在 `0.0 ≤ q < 1.0` 之間的浮點數 *q* 來表示多個符號。當符號的概率分佈偏斜時，算術編碼能提供比霍夫曼編碼更緊湊的表示，但它的處理速度通常比霍夫曼編碼慢。

   讓我們回到紅綠燈的例子。如果你對之前霍夫曼編碼的結果不滿意，該結果的平均位元數為 1.6，而你希望使用算術編碼，則在算術編碼中，每個符號會首先根據其概率被分配到 `[0, 1)` 區間中的一個範圍。隨著我們編碼更多符號，這個範圍會逐漸縮小，最終得出一個單一數字來表示整個序列。具體步驟如下。
    讓我們使用之前相同的機率：
    - 綠色     (50%)
    - 紅色       (40%)
    - 黃色    ( 9%)
    - 關閉d  ( 1%)

    我們將為每個符號分配以下範圍：

    - 綠色:    `[0.00, 0.50)`
    - 紅色:      `[0.50, 0.90)`
    - 黃色:   `[0.90, 0.99)`
    - 關閉d: `[0.99, 1.00)`


    現在，我們來編碼一個紅綠燈狀態序列：“綠色、紅色、黃色、綠色”

    1. 從區間 `[0, 1)` 開始

    2. 第一個號誌（綠色）：
    - 計算新的低範圍 `new_low` 和高範圍 `new_high`：
        - `new_low = low + (high - low) • cumulative(s) / total`
        - `new_high = low + (high - low) • (cumulative(s) + prob(s)) / total`
        - 對於綠色，我們的計算為：
        - `new_low = 0 + (0.5 - 0) • 0 / 1.0`
        - `new_high = 0 + (0.5 - 0) • (0 + 0.5) / 1.0`
        - 因此，將範圍縮窄到 `[0.00, 0.50)`

    3. 第二個號誌 (紅色):
        - From previous range: `[0.00, 0.50)`
        - `new_low = 0 + (0.50 - 0) * 0.50 / 1`
        - `new_high = 0 + (0.50 - 0) * (0.50 + 0.40) / 1`
        - 紅色在區間 `[0.25, 0.45)`

    4. 第三個號誌 (黃色):
        - From previous range: `[0.25, 0.45)`
        - `new_low = 0.25 + (0.45 - 0.25) * (0.50 + 0.40) / 1`
        - `new_high = 0.25 + (0.45 - 0.25) * (0.50 + 0.40 + 0.09) / 1`
        - 黃色在區間`[0.43, 0.448)`

    5. 第四個號誌 (關閉d):
    - From previous range: `[0.43, 0.448)`
        - `new_low = 0.43 + (0.448 - 0.43) * (0.50 + 0.40 + 0.09) / 1`
        - `new_low = 0.43 + (0.448 - 0.43) * (0.50 + 0.40 + 0.09 + 0.01) / 1`
        - 綠色在區間`[0.44782, 0.448)`

最終的區間為 `[0.44782, 0.448)`。在這個區間內的任何數字（我們選擇下限 0.44782，包含此值）都能代表我們的整個序列“綠色、紅色、黃色、關閉”。

要進行解碼，我們會從 0.44782 開始，根據我們原始的概率範圍來確定這個數字對應的符號，然後更新範圍並重複這個過程。

在這個例子中，由於樣本過短，算術編碼無法有效地節省空間，因為沒有足夠的資料模式可供利用。對於更長的序列，算術編碼能夠接近符號的理論熵極限 **1.408 位元**：`-(0.50 * log2(0.50) + 0.40 * log2(0.40) + 0.09 * log2(0.09) + 0.01 * log2(0.01)) ≈ 1.408`

實際應用中，還需要考慮額外的因素，例如如何管理資料精度，這些在這個簡化的例子中並未涉及。

4. **預測與殘差編碼**：
   預測是利用過去的資料來預測未來的資料。我們編碼的是預測值與實際值之間的差異（殘差），而非實際資料。線性預測編碼（LPC）是一種常見方法，它通過對之前的樣本進行線性預測來估計當前樣本。由於殘差通常具有較低的熵，因此可以更高效地進行編碼。
---
title: Color Formats
sidebar_position: 2
---



# 色彩格式

為了表示顏色值，需要確定一種色彩格式。色彩格式主要包括三個部分：
[色彩模型](#color-models)（包括[元件順序](#component-order)以及有時的
[色彩採樣](#chroma-subsampling)）、[bit-depth](#bit-depth)，
以及是否為[打包格式或平面格式](#packed-vs-planar)。
在某些情況下，[endianness](#endianness) 也可能是需要考慮的因素。

## 色彩模型

色彩模型是一種用於在影片或圖像中以資料形式表示顏色的方法。
不同的色彩模型以不同方式儲存顏色和亮度訊息。雖然有許多不同的色彩模型，
本節將重點介紹那些最常用於圖像和影片的模型。

### RGB

RGB 可能是最為人熟知的色彩模型，主要用於圖像編碼。RGB 包含紅色、綠色和藍色三個顏色通道，這
些通道會合併以確定每個像素的顏色。RGB 是顯示器和電視顯示圖像時所使用的最終色彩模型，因為屏幕上的像素由紅、綠、藍三種 LED 組成。
儘管如此，RGB 不常用於影片編碼，因為其他色彩模型能提供更高的壓縮效率。

### YUV

YUV，也稱為 YCbCr，是影片編碼中最常用的色彩模型。它由三個組件構成：Y（亮度，Luma）表示亮度，另外兩個色彩平面則代表顏色。一般來說，影片播放器需要將 YUV 轉換成 RGB 才能顯示，但使用 YUV 進行編碼比 RGB 有明顯的壓縮優勢。

YCbCr 的主要優勢在於色彩子採樣技術。這意味著色彩（顏

色）組件可以用低於亮度組件的分辨率進行編碼，從而減少檔案大小。你可以在[後面](#chroma-subsampling)了解更多關於色彩採樣的資訊。

### 元件順序

色彩模型中的元件順序通過簡單地書寫出來來表示。例如，`RGB` 表示紅色在前，其次是綠色，最後是藍色；而 `BGR` 則表示藍色在前，綠色在中，紅色在最後。

## Bit depth

Bit depth 指的是每個樣本值的位數。Bit depth 的表示方式主要有兩種：

- 每個元件的位元數(bits)。例如，`RGB888` 表示 `RGB 色彩模型，
每個顏色通道有 8 位`，而 `RGB565` 表示 `RGB 色彩模型，
紅色通道 5 位，綠色通道 6 位，藍色通道 5 位`。
- 每個樣本的位元數。例如，`RGB24` 表示 `RGB 色彩模型，紅色、
綠色和藍色通道合計 24 位元`。這種表示方式不夠精確，
因為無法確定每個通道的具體位數。`RGB565`、`RGB556` 和
 `RGB655`（儘管後兩者不太合理，因為眼睛對綠光最敏感）都被簡稱為 `RGB16`。

## Packed vs planar

Components can be stored either packed, where all
components are interleaved (here, `RGB`):

```
Sample number:   1   2   3   4   5
Data:          RGB RGB RGB RGB RGB
```

or stored separately for each component:

```
Sample number: 1 2 3 4 5
Data:          R R R R R...
Data:          G G G G G...
Data:          B B B B B...
```

In planar formats, many operations can be easier to implement, as it
is possible to implement the algorithm once and then operate on all
planes. On the other hand, packed formats are simpler and often used
in hardware.[^vlc-wiki-yuv]

## Endianness

Different computer architectures store numbers differently. For more
information, visit [the Wikipedia article on
endianness](//wikipedia.org/wiki/Endianness). There are two main ways
to store numbers with more than 8 bits (1 is the least significant
byte and 4 is the most significant byte, here 4 bytes):

- Most significant byte first, little endian, `4321`. This is what
  x86-family processors use.
- Least significant byte first, big endian, `1234`. This is what
  PowerPC-family processors use.

This can be important for color formats, as some computers might store
it in their native endianness. VapourSynth doesn't seem to care about
endianness, but FFmpeg does.

For example, `RGB565` might store its two bytes in `12` or `21` order,
and if they are read in the wrong order, it will produce garbage.

## Chroma subsampling

In [Y'CbCr](#yuv) signals, there are three widely used
variants of chroma subsampling:

- 4:2:0 which has half the vertical and horizontal chroma resolution
- 4:2:2 which has half the horizontal chroma resolution but full
  vertical resolution
- 4:4:4 which has full chroma resolution (no subsampling)

4:2:2 is not particularly useful over the other options, so this guide
will focus on 4:2:0 and 4:4:4.

4:2:0 is the most commonly used format for videos. Nearly every DVD,
blu-ray, camera recording, etc. uses 4:2:0 subsampling. This is because,
in the majority of cases, human eyes do not notice the reduction in
chroma resolution. There is very little benefit to using 4:4:4 in the
average case.

However, there are some exceptions. The most notable is screen
recordings. Things like text overlays, video game UI overlays,
etc. have very fine, color-dependent detail that can be destroyed by
chroma subsampling and result in an aliased look to the
video. Therefore, it is recommended to use 4:4:4 subsampling when
recording your screen, and 4:2:0 subsampling in most other cases.

## Common formats

| VS name     | FFmpeg name                                                                 | Meaning                                                                                               |
| ----------- | --------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| `GRAY8`     | `gray8`                                                                     | Brightness only, 8 bits, packed                                                                       |
| `GRAY16`    | `gray16le`, `gray16be` (the suffix specifies the [endianness](#endianness)) | Brightness only, 16 bits                                                                              |
| `RGB888`    | `rgb24`                                                                     | red, green, blue, 8 bits per component                                                                |
| `YUV420P8`  | `yuv420p`                                                                   | luma, chroma blue, chroma red, 8 bits per component, planar, 4:2:0 [subsampling](#chroma-subsampling) |
| `YUV422P8`  | `yuv422p`                                                                   | luma, chroma blue, chroma red, 8 bits per component, planar, 4:2:2 subsampling                        |
| `YUV444P8`  | `yuv444p`                                                                   | luma, chroma blue, chroma red, 8 bits per component, planar, no subsampling                           |
| `YUV420P10` | `yuv420p10le`, `yuv420p10le`                                                | luma, chroma blue, chroma red, 10 bits per component, planar, 4:2:0 subsampling                       |
| `YUV422P10` | `yuv422p10le`, `yuv422p10le`                                                | luma, chroma blue, chroma red, 10 bits per component, planar, 4:2:2 subsampling                       |
| `YUV444P10` | `yuv444p10le`, `yuv444p10le`                                                | luma, chroma blue, chroma red, 10 bits per component, planar, no subsampling                          |

## References

[^vlc-wiki-yuv]: [YUV - VideoLAN Wiki](https://wiki.videolan.org/YUV/#Packed_formats)
